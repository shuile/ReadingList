# 《Head First 设计模式》

## Chapter 1 设计模式入门

* 采用设计模式沟通
  * 模式背后象征着质量、特性、约束
  * 彼此更好的知道想法
  * 保持在设计层次，不会压低到对象和类上面
  * 不容易产生误解
  * 帮助初级开发人员成长

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
* OO模式
  * 策略模式--定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

```text
要点
    * 知道OO基础，并不足以让你设计出良好的OO系统
    * 良好的OO设计必须具备可复用、可扩充、可维护三个特性
    * 模式可以让我们建造出具有良好OO设计质量的系统
    * 模式被认为是历经验证的OO设计经验
    * 模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中
    * 模式不是被发明，而是被发现
    * 大多数的模式和原则，都是着眼于软件变化的主题
    * 大多数的模式都允许系统局部改变独立于其他部分
    * 我们常把系统中变化的部分抽出来封装
    * 模式让开发人员之间有共享的语言，能够最大化沟通的价值
```

## Chapter 2 观察者（Observer）模式

* 设计原则：为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

```java
class Station {
    addObserver(Observer observer);
    removeObserver(Observer observer);
    notifyObservers(WeatherData data) {
        update(data);
    }
}
class WeatherData {
    float temperature;
    float humidity;
    float pressure;
    float getTemperature() {
        return temperature;
    }
    float getHumidity() {
        return humidity;
    }
    float getPressure() {
        return pressure;
    }
}
class board {
    update(WeatherData data) {
        ...
    }
}
```

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
* OO模式
  * 策略模式
  * 观察者模式-在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会受到通知，并自动更新。

```text
要点
    * 观察者模式定义了对象之间一对多的关系
    * 主题（也就是可观察者）用一个共同的接口来更新观察者
    * 观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口
    * 使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）
    * 有多个观察者时，不可以依赖特定的通知次序
    * Java有多重观察者模式的实现，包括了通用的java.util.Observable
    * 要注意java.util.Ovservable是线上所带来的的一些问题
    * 如果有必要的话，可以实现自己的Observable
    * Swing大量使用观察者模式，许多GUI框架也是如此
    * 此模式也被应用在许多地方，例如：JavaBeans、RMI
```

## Chapter 3 装饰对象

* 开放-关闭原则
  * 设计原则：开放-关闭原则，类应该对扩展开放，对修改关闭。
    * 我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接收新的功能来应对改变的需求。

* 装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案
  * 装饰者和被装饰对象有相同的超类型
  * 你可以用一个或多个装饰者包装一个对象
  * 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它
  * 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的
  * 对象可以在任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象

* 真实世界的装饰者：Java I/O装饰java.io类

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 对扩展开放，对修改关闭
* OO模式
  * 策略模式
  * 观察者模式
  * 装饰者模式--动态地将责任附加到对象上，想要扩展功能，装饰者提供有别于继承的另一种选择

```text
要点
    * 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案
    * 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码
    * 组合和委托可用于在运行时动态地加上新的行为
    * 除了继承，装饰者模式也可以让我们扩展行为
    * 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
    * 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）
    * 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的
    * 你可以用无数个装饰者包装一个组件
    * 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
    * 装饰者导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂
```

## Chapter 4 工厂模式

所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。

* 创建者(Creator)类
  * 抽象创建者类--PizzaStore
  * 具体创建者类--NYPizzaStore、ChicagoPizzaStore
* 产品类
  * 抽象产品类--Pizza
  * 具体产品类--NYStyleCheesePizza、ChicagoStyleCheesePizza

* 工厂方法定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

* 依赖倒置原则
  * 设计原则：要依赖抽象，不要依赖具体类
  * 在依赖倒置原则中的倒置指的是和一般OO设计的思考方式完全相反。
  * 指导方针：
    * 变量不可以持有具体类的引用
    * 不要让类派生自具体类
    * 不要覆盖基类这种已实现的方法

* 抽象工厂模式--提供一个皆苦，用于创建相关或依赖对象的家族，而不需要明确指定具体类
  * 抽象工厂的方法常以工厂方法的方式实现。

* OO基础
* OO原则
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
* OO模式
  * 策略模式
  * 观察者模式
  * 装饰者模式
  * 抽象工厂模式--提供一个接口，用于创建相关依赖对象的家族，而不需要明确指定具体类
  * 工厂方法模式--一定了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

```text
要点
  * 所有的工厂都是用来封装对象的创建
  * 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦
  * 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象
  * 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中
  * 所有工工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合
  * 工厂方法允许类将实例化延迟到子类进行
  * 抽象工厂创建相关的独享家族，而不需要依赖它们的具体类
  * 依赖倒置原则，知道我们避免依赖具体类性，而要尽量依赖抽象
  * 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是要针对具体类编程
```

## Chapter 5 单件模式

* 单件模式--确保一个类只有一个实例，并提供一个全局访问点

* 处理多线程--只要把getInstance()编程同步（synchronized）方法，多线程灾难就可以轻易地解决了
  * 能够改善多线程么？
    * 如果getInstance()的性能对应用程序不是很关键，就什么都别做
    * 如果“急切”创建实例，而不用延迟实例化的做法
      * 在静态初始化器中创建单件。这段代码保证了线程安全
    * 用“双重检查加锁”，在getInstance()中减少使用同步
      * 第一次检查实例，如果不存在，就进入同步区
      * 进入同步区后，再检查一次，如果仍为null，才创建实例
      * volatile关键词确保，当uniqueInstance变量被初始化成Singleton实例时，多个线程正确地处理uniqueInstance变量

* OO基础
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
* OO模式
  * 策略模式
  * 观察者模式
  * 装饰者模式
  * 抽象工厂模式
  * 工厂方法模式
  * 单件模式--确保一个类只有一个实例，并提供全局访问点

```text
要点
  * 单件模式确保程序中一个类最多只有一个实例
  * 单件模式也提供访问这个实例的全局点
  * 在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量
  * 确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多线程的问题（我们必须认定所有的程序都是多线程的）
  * 如果不是采用第五版的Java 2，双重检查加锁实现会失效
  * 小心，你如果使用多个类加载器，可能导致单件失效而产生多个实例
  * 如果使用JVM 1.2或之前的版本，你必须建立单件注册表，以免垃圾收集器将单件回收
```

## Chapter 6 命令模式

* 命令模式--将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

* 空对象--在许多设计模式中，都会看奥空对象的使用。甚至有些时候，空对象本身也被视为是一种设计模式

* 队列请求
  * 命令可以将运算快打包（一个接受者和一组动作），然后将它传来传去，就像是一般的对象一样。例如：日程安排（Scheduler）、线程池、工作队列等。

* 日志请求

* OO基础
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
* 模式
  * 命令模式--将请求封装成对象，这可以让你使用不同的请求、的队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作

```text
要点
  * 命令模式将发出请求的对象和执行请求的对象解耦
  * 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作
  * 调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用
  * 调用者可以接受命令当作参数，甚至在运行时动态地进行
  * 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行钱的状态
  * 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销
  * 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者
  * 命令也可以用来实现日志和事务系统t
```

## Chapter 7 适配器模式与外观模式

* 适配器模式--将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
* 外观模式--提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

* 外观不只是简化了接口，也将客户从组件的子系统中解耦。
* 外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同接口。

* 最少知识原则
  * 设计原则--只和你的密友谈话
  * 避免：就任何对象而言，在该对象的方法内，我们只应该调用属于以下范围的方法
    * 该对象本身
    * 被当做方法的参数而传递进来的对象
    * 此方法所创建或实例化的任何对象
    * 对象的任何组件

* OO基础
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
  * 只和朋友交谈
* OO模式
  * 适配器模式--将一个类的接口，转换成客户期望的另一个接口。适配器让原本不兼容的类可以合作无间。
  * 外观模式--提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

```text
要点
  * 当需要使用一个现有的类而其接口并不符合你的需求时，就是用适配器。
  * 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。
  * 适配器改变接口以符合客户的期望。
  * 外观将客户从一个负载的子系统中解耦。
  * 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。
  * 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。
  * 适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。
  * 你可以为一个子系统实现一个以上的外观。
  * 适配器讲一个对象包装起来以改变其接口；装饰者讲一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口。
```

## Chapter 8 模板方法模式

* 模板方法模式--在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板放阿飞使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

* 好莱坞原则--别调用（打电话给）我们，我们会调用（打电话给）你。
  * 好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖底层组件，而底层组件又依赖高层组件，而高层组件又依赖边侧组件，而边侧组件又依赖底层组件时，依赖腐败就发生了。在这种情况下，没有人可以轻易地搞懂系统是如何设计的。
  * 在好莱坞原则之下，我们允许底层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么样使用这些底层组件，换句话说，高层组件对待底层组件的方式是“别调用我们，我们会调用你”。

* OO基础
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
  * 只和朋友交谈
  * 别找我，我会找你
* OO模式
  * 模板方法模式--在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

```text
要点
  * "模板方法"定义了算法的步骤，把这些步骤的实现延迟到子类。
  * 模板方法模式为我们提供了一种代码复用的重要技巧。
  * 模板方法的抽象类可以定义具体方法、抽象方法和钩子。
  * 抽象方法由子类实现。
  * 钩子是一种方法，它在抽象类中不做事，或者制作默认的事情，子类可以选择要不要去覆盖它。
  * 为了防止子类改变模板方法中的算法，可以将模板方法声明为final。
  * 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用低层模块。
  * 你将在真实世界代码中看到模板方法模式的许多变体，不要期待他们全都是一眼就可以被你认出。
  * 策略模式和模板方法模式都封装算法，一个用组合，一个用继承。
  * 工厂方法是模板方法的一种特殊版本。
```

## Chapter 9 迭代器与组合模式

* 迭代器模式--提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。

* 单一责任原则
  * 设计原则--一个类应用只有一个引起变化的原因。
  * 内聚--用来度量一个类或模块紧密地达到单一目的或责任。

* 组合模式--允许你讲对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
  * 组合组合模式让我们能用属性昂视创建对象的结构，树里面包含了组合以及个别的对象。

* OO基础
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
  * 只和朋友交谈
  * 别找我，我会找你
  * 类应该只有一个改变的理由
* OO模式
  * 迭代器模式--提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示
  * 组合模式--允许你讲对象组成树形结构来表现“”整体/部分的层次结构体。组合让客户以一致的方式处理个别对象和对象组合。
  
```text
要点
  * 迭代器允许访问聚合的元素，而不需要暴露它的内部结构
  * 迭代器将遍历聚合的工作封装进一个对象中
  * 迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制
  * 我们应该努力让一个类只分配一个责任
  * 组合模式提供一个结构，可同时包容个别对象和组合对象
  * 组合模式允许客户对个别对象以及组合对象一视同仁
  * 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点
  * 在实现组合模式时，有许多设计上的折衷。你要根据需要平衡透明性和安全性
```

## Chpater 10 状态模式

* 状态模式--允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

* OO基础
* *OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
  * 只和朋友交谈
  * 别找我，我会找你
  * 类应该只有一个改变的理由
* OO模式
  * 状态模式

```text
要点
  * 状态模式允许一个对象基于内部状态而拥有不同的行为
  * 和程序状态机（PSM）不同，状态模式用类代表状态
  * Context会将行为委托给当前状态对象
  * 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了
  * 状态模式和策略模式有相同的类图，但是它们的意图不同
  * 策略模式通常会用行为或算法来配置Context类
  * 状态模式允许Context随着状态的改变而改变行为
  * 状态转换可以由State类或Context类控制
  * 使用状态模式通常会导致设计中类的树木大量增加
  * 状态类可以被多个Context实例共享
```
