# 《Head First 设计模式》

## Chapter 1 设计模式入门

* 采用设计模式沟通
  * 模式背后象征着质量、特性、约束
  * 彼此更好的知道想法
  * 保持在设计层次，不会压低到对象和类上面
  * 不容易产生误解
  * 帮助初级开发人员成长

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
* OO模式
  * 策略模式--定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

```text
要点
    * 知道OO基础，并不足以让你设计出良好的OO系统
    * 良好的OO设计必须具备可复用、可扩充、可维护三个特性
    * 模式可以让我们建造出具有良好OO设计质量的系统
    * 模式被认为是历经验证的OO设计经验
    * 模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中
    * 模式不是被发明，而是被发现
    * 大多数的模式和原则，都是着眼于软件变化的主题
    * 大多数的模式都允许系统局部改变独立于其他部分
    * 我们常把系统中变化的部分抽出来封装
    * 模式让开发人员之间有共享的语言，能够最大化沟通的价值
```

## Chapter 2 观察者（Observer）模式

* 设计原则：为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

```java
class Station {
    addObserver(Observer observer);
    removeObserver(Observer observer);
    notifyObservers(WeatherData data) {
        update(data);
    }
}
class WeatherData {
    float temperature;
    float humidity;
    float pressure;
    float getTemperature() {
        return temperature;
    }
    float getHumidity() {
        return humidity;
    }
    float getPressure() {
        return pressure;
    }
}
class board {
    update(WeatherData data) {
        ...
    }
}
```

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
* OO模式
  * 策略模式
  * 观察者模式-在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会受到通知，并自动更新。

```text
要点
    * 观察者模式定义了对象之间一对多的关系
    * 主题（也就是可观察者）用一个共同的接口来更新观察者
    * 观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口
    * 使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）
    * 有多个观察者时，不可以依赖特定的通知次序
    * Java有多重观察者模式的实现，包括了通用的java.util.Observable
    * 要注意java.util.Ovservable是线上所带来的的一些问题
    * 如果有必要的话，可以实现自己的Observable
    * Swing大量使用观察者模式，许多GUI框架也是如此
    * 此模式也被应用在许多地方，例如：JavaBeans、RMI
```

## Chapter 3 装饰对象

* 开放-关闭原则
  * 设计原则：开放-关闭原则，类应该对扩展开放，对修改关闭。
    * 我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接收新的功能来应对改变的需求。

* 装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案
  * 装饰者和被装饰对象有相同的超类型
  * 你可以用一个或多个装饰者包装一个对象
  * 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它
  * 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的
  * 对象可以在任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象

* 真实世界的装饰者：Java I/O装饰java.io类

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 对扩展开放，对修改关闭
* OO模式
  * 策略模式
  * 观察者模式
  * 装饰者模式--动态地将责任附加到对象上，想要扩展功能，装饰者提供有别于继承的另一种选择

```text
要点
    * 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案
    * 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码
    * 组合和委托可用于在运行时动态地加上新的行为
    * 除了继承，装饰者模式也可以让我们扩展行为
    * 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
    * 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）
    * 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的
    * 你可以用无数个装饰者包装一个组件
    * 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
    * 装饰者导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂
```

## Chapter 4 工厂模式

