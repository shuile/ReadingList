# 《Head First 设计模式》

## Chapter 1 设计模式入门

* 采用设计模式沟通
  * 模式背后象征着质量、特性、约束
  * 彼此更好的知道想法
  * 保持在设计层次，不会压低到对象和类上面
  * 不容易产生误解
  * 帮助初级开发人员成长

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
* OO模式
  * 策略模式--定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

```text
要点
    * 知道OO基础，并不足以让你设计出良好的OO系统
    * 良好的OO设计必须具备可复用、可扩充、可维护三个特性
    * 模式可以让我们建造出具有良好OO设计质量的系统
    * 模式被认为是历经验证的OO设计经验
    * 模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中
    * 模式不是被发明，而是被发现
    * 大多数的模式和原则，都是着眼于软件变化的主题
    * 大多数的模式都允许系统局部改变独立于其他部分
    * 我们常把系统中变化的部分抽出来封装
    * 模式让开发人员之间有共享的语言，能够最大化沟通的价值
```

## Chapter 2 观察者（Observer）模式

* 设计原则：为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

```java
class Station {
    addObserver(Observer observer);
    removeObserver(Observer observer);
    notifyObservers(WeatherData data) {
        update(data);
    }
}
class WeatherData {
    float temperature;
    float humidity;
    float pressure;
    float getTemperature() {
        return temperature;
    }
    float getHumidity() {
        return humidity;
    }
    float getPressure() {
        return pressure;
    }
}
class board {
    update(WeatherData data) {
        ...
    }
}
```

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
* OO模式
  * 策略模式
  * 观察者模式-在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会受到通知，并自动更新。

```text
要点
    * 观察者模式定义了对象之间一对多的关系
    * 主题（也就是可观察者）用一个共同的接口来更新观察者
    * 观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口
    * 使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）
    * 有多个观察者时，不可以依赖特定的通知次序
    * Java有多重观察者模式的实现，包括了通用的java.util.Observable
    * 要注意java.util.Ovservable是线上所带来的的一些问题
    * 如果有必要的话，可以实现自己的Observable
    * Swing大量使用观察者模式，许多GUI框架也是如此
    * 此模式也被应用在许多地方，例如：JavaBeans、RMI
```

## Chapter 3 装饰对象

* 开放-关闭原则
  * 设计原则：开放-关闭原则，类应该对扩展开放，对修改关闭。
    * 我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。这样的设计具有弹性可以应对改变，可以接收新的功能来应对改变的需求。

* 装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案
  * 装饰者和被装饰对象有相同的超类型
  * 你可以用一个或多个装饰者包装一个对象
  * 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它
  * 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的
  * 对象可以在任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象

* 真实世界的装饰者：Java I/O装饰java.io类

* OO基础
  * 抽象
  * 封装
  * 多态
  * 继承
* OO原则
  * 封装变化
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 对扩展开放，对修改关闭
* OO模式
  * 策略模式
  * 观察者模式
  * 装饰者模式--动态地将责任附加到对象上，想要扩展功能，装饰者提供有别于继承的另一种选择

```text
要点
    * 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案
    * 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码
    * 组合和委托可用于在运行时动态地加上新的行为
    * 除了继承，装饰者模式也可以让我们扩展行为
    * 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
    * 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）
    * 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的
    * 你可以用无数个装饰者包装一个组件
    * 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
    * 装饰者导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂
```

## Chapter 4 工厂模式

所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。

* 创建者(Creator)类
  * 抽象创建者类--PizzaStore
  * 具体创建者类--NYPizzaStore、ChicagoPizzaStore
* 产品类
  * 抽象产品类--Pizza
  * 具体产品类--NYStyleCheesePizza、ChicagoStyleCheesePizza

* 工厂方法定义：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

* 依赖倒置原则
  * 设计原则：要依赖抽象，不要依赖具体类
  * 在依赖倒置原则中的倒置指的是和一般OO设计的思考方式完全相反。
  * 指导方针：
    * 变量不可以持有具体类的引用
    * 不要让类派生自具体类
    * 不要覆盖基类这种已实现的方法

* 抽象工厂模式--提供一个皆苦，用于创建相关或依赖对象的家族，而不需要明确指定具体类
  * 抽象工厂的方法常以工厂方法的方式实现。

* OO基础
* OO原则
  * 多用组合，少用继承
  * 针对接口编程，不针对实现编程
  * 为交互对象之间的松耦合设计而努力
  * 类应该对扩展开放，对修改关闭
  * 依赖抽象，不要依赖具体类
* OO模式
  * 策略模式
  * 观察者模式
  * 装饰者模式
  * 抽象工厂模式--提供一个接口，用于创建相关依赖对象的家族，而不需要明确指定具体类
  * 工厂方法模式--一定了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

```text
要点
  * 所有的工厂都是用来封装对象的创建
  * 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦
  * 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象
  * 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中
  * 所有工工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合
  * 工厂方法允许类将实例化延迟到子类进行
  * 抽象工厂创建相关的独享家族，而不需要依赖它们的具体类
  * 依赖倒置原则，知道我们避免依赖具体类性，而要尽量依赖抽象
  * 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是要针对具体类编程
```

